<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris — ScalForce Style</title>
  <style>
    :root{
      --bg:#140a1a;
      --primary:#5E2497;
      --primary-700:#43186c;
      --accent:#ff8a00;
      --accent-700:#cc6d00;
      --text:#ffffff;
      --muted:#cfc6d9;
      --card:#2b1943;
      --success:#36c38d;
      --block:30px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Poppins, system-ui, Segoe UI, Roboto, Arial,sans-serif;background:linear-gradient(180deg,#1a0f26,#140a1a);color:var(--text);height:100vh;display:flex;flex-direction:column}
    header{
      position:sticky;top:0;z-index:10;backdrop-filter:saturate(140%) blur(8px);
      background:linear-gradient(180deg, rgba(20,10,26,.9), rgba(20,10,26,.6) 80%, rgba(20,10,26,0));
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .nav{display:flex;align-items:center;justify-content:space-between;gap:1rem;padding:1rem 2rem;max-width:1200px;margin:0 auto;}
    .brand{display:flex;align-items:center;gap:.8rem;font-weight:800;letter-spacing:.5px}
    .brand img{height:42px;width:auto;display:block;filter:drop-shadow(0 2px 10px rgba(255,138,0,.2))}
    .brand span{font-size:1.3rem;color:var(--accent)}
    .nav-actions{display:flex;align-items:center;gap:.6rem}
    .btn{display:inline-flex;align-items:center;gap:.5rem;padding:.6rem 1rem;border-radius:999px;border:1px solid transparent;transition:.2s ease;font-weight:600;cursor:pointer; text-decoration: none;}
    .btn.primary{background:var(--accent);color:#1b0d27}
    .btn.primary:hover{background:var(--accent-700)}

    main{flex:1;display:flex;align-items:center;justify-content:center;}
    .wrap{display:flex;gap:32px;padding:2rem;align-items:flex-start}
    .board{background:var(--card);padding:14px;border-radius:20px;box-shadow:0 20px 50px rgba(0,0,0,.35);border:3px solid rgba(255,255,255,.06)}
    canvas{display:block;background:#1a0f26;border-radius:10px}
    .sidebar{min-width:240px;display:flex;flex-direction:column;gap:16px}
    .panel{background:linear-gradient(145deg,var(--card),#1a0f2a);padding:16px;border-radius:18px;border:2px solid rgba(255,255,255,.06);box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h1{font-size:20px;margin:0 0 8px;font-weight:800;color:var(--accent)}
    .small{font-size:13px;color:var(--muted)}
    .score{font-size:24px;margin:8px 0;font-weight:700;color:var(--accent)}
    .controls{font-size:13px;line-height:1.6;color:var(--muted)}
    button{background:var(--accent);color:#1b0d27;border:0;padding:10px 14px;border-radius:999px;cursor:pointer;font-weight:700;transition:.2s ease}
    button:hover{background:var(--accent-700)}
    footer{margin-top:10px;font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div class="nav">
      <a class="brand">
        <img src="Logo.png" alt="Logo SCALFORCE" onerror="this.style.display='none'">
        <span>ScalForce</span>
      </a>
      <nav class="nav-actions">
        <a class="btn primary" href="../ScalForce.html">Voltar</a>
      </nav>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div class="board">
        <canvas id="game" width="300" height="600"></canvas>
      </div>

      <div class="sidebar">
        <div class="panel">
          <!-- Botão Iniciar adicionado na frente do título -->
          <div style="display:flex;align-items:center;gap:10px;">
            <h1>Tetris</h1>
             <button id="startBtn" class="btn primary" style="padding:6px 10px;font-size:13px;">Iniciar</button>
          </div>
          <div class="small">Treine sua estratégia 
            e coordenação motora</div>
        </div>

        <div class="panel">
          <div class="small">Próxima peça</div>
          <canvas id="next" width="120" height="100" style="display:block;margin-top:8px;background:#1a0f26;border-radius:10px"></canvas>
        </div>

        
<div class="panel" style="display:flex; justify-content:space-between; align-items:flex-start; gap:20px;">
  <!-- Coluna da esquerda -->
  <div>
    <div class="small">Pontos</div>
    <div id="score" class="score">0</div>
    <div class="small">Linhas: <span id="lines">0</span></div>
    <div class="small">Nível: <span id="level">1</span></div>
  </div>

  <!-- Coluna da direita -->
  <div>
    <div class="small">Recordes</div>
    <div id="highscores" class="score" style="font-size:16px; line-height:1.4; text-align:right;"></div>
  </div>
</div>




        <div class="panel controls">
          <div class="small">Controles:</div>
          <div>Mover → A/D OU Analógico Esquerdo ← → / LB / RB</div>
          <div>Rotacionar (W) OU Botão X </div>
          <div>Queda suave (S) OU Botão B OU Analógico Esquerdo ↓</div>
          <div>Queda rápida (Space) OU Botão A </div>
          <div>Pausar (P) OU Botão Start</div>
          <div>Reiniciar (R) OU Botão Y</div>
        </div>
      </div>
    
<div id="gameOverBox" style="
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
">
  <div style="
    background: var(--card);
    padding: 30px;
    border-radius: 20px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  ">
    <h2 style="color: var(--accent); font-size: 28px; margin-bottom: 16px;">Game Over</h2>
    <p style="font-size: 18px; margin-bottom: 20px; color: var(--text);">Pontuação: <span id="finalScore">0</span></p>
    <button onclick="window.location.href='JG29-Tetris.html'" style="font-size:16px;">Reiniciar</button>
  </div>
</div>

  </main>

<script>
const COLS = 10, ROWS = 20;
const BLOCK = 30; // tamanho do bloco em px
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;

const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');

// paleta de cores para as peças
const COLORS = {
  I: '#00f0f0',
  J: '#0000f0',
  L: '#f0a000',
  O: '#f0f000',
  S: '#00f000',
  T: '#a000f0',
  Z: '#f00000',
  X: '#223344'
};

// definições de peças - matrizes 4x4
const SHAPES = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  J: [[1,0,0],[1,1,1],[0,0,0]],
  L: [[0,0,1],[1,1,1],[0,0,0]],
  O: [[1,1],[1,1]],
  S: [[0,1,1],[1,1,0],[0,0,0]],
  T: [[0,1,0],[1,1,1],[0,0,0]],
  Z: [[1,1,0],[0,1,1],[0,0,0]]
};

// tabuleiro vazio
function createMatrix(w,h){
  const m = [];
  while(h--) m.push(new Array(w).fill(0));
  return m;
}

let arena = createMatrix(COLS, ROWS);

// peça atual
let piece = null;
let next = null;
let dropCounter = 0;
let dropInterval = 1000; // ms
let lastTime = 0;
let score = 0;
let lines = 0;
let level = 1;
let gameOver = false;
let highscores = JSON.parse(localStorage.getItem("tetrisHighscores") || "[]");
let paused = true; // **inicia pausado — o jogo só começa ao clicar em Iniciar**

// funções utilitárias
function drawCell(x,y,color){
  ctx.fillStyle = color;
  ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
  ctx.strokeStyle = '#071827';
  ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
}

function draw(){
  // Fundo
  ctx.fillStyle = '#081426';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // === Grade quadriculada ===
  ctx.strokeStyle = "rgba(255,255,255,0.08)"; // cor clara e bem sutil
  ctx.lineWidth = 1;

  // Linhas verticais
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * BLOCK, 0);
    ctx.lineTo(x * BLOCK, canvas.height);
    ctx.stroke();
  }

  // Linhas horizontais
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * BLOCK);
    ctx.lineTo(canvas.width, y * BLOCK);
    ctx.stroke();
  }

  // === Arena preenchida ===
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(arena[y][x]) drawCell(x,y,arena[y][x]);
    }
  }

  // === Peça atual ===
  if(piece){
    const matrix = piece.matrix;
    for(let y=0;y<matrix.length;y++){
      for(let x=0;x<matrix[y].length;x++){
        if(matrix[y][x]) drawCell(piece.x + x, piece.y + y, piece.color);
      }
    }
  }
}


function drawNext(){
  nctx.fillStyle = '#071827';
  nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  if(!next) return;
  const matrix = next.matrix;
  const size = matrix.length;
  const start = Math.floor((nextCanvas.width/ BLOCK - size)/2);
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      if(matrix[y][x]){
        nctx.fillStyle = next.color;
        nctx.fillRect((start + x)*BLOCK/2, (1+y)*BLOCK/2, BLOCK/2 -1, BLOCK/2 -1);
        nctx.strokeStyle = '#071827';
        nctx.strokeRect((start + x)*BLOCK/2, (1+y)*BLOCK/2, BLOCK/2 -1, BLOCK/2 -1);
      }
    }
  }
}

function rotate(matrix, dir){
  // transposta
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir>0) matrix.forEach(row => row.reverse());
  else matrix.reverse();
}

function collide(arena, piece){
  const m = piece.matrix;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]){
        const ay = piece.y + y;
        const ax = piece.x + x;
        if(ay<0 || ay>=ROWS || ax<0 || ax>=COLS || (arena[ay] && arena[ay][ax])) return true;
      }
    }
  }
  return false;
}

function merge(arena, piece){
  const m = piece.matrix;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]){
        if(arena[piece.y + y]) arena[piece.y + y][piece.x + x] = piece.color;
      }
    }
  }
}

function sweep(){
  let rowCount = 0;
  outer: for(let y=ROWS-1;y>=0;y--){
    for(let x=0;x<COLS;x++){
      if(!arena[y][x]){
        continue outer;
      }
    }
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    y++;
    rowCount++;
  }
  if(rowCount>0){
    const points = [0,40,100,300,1200];
    score += points[rowCount] * level;
    lines += rowCount;
    const newLevel = Math.floor(lines / 10) + 1;
    if(newLevel > level){
      level = newLevel;
      dropInterval = Math.max(100, 1000 - (level-1)*100);
    }
    updateInfo();
  }
}

function updateInfo(){
  document.getElementById('score').innerText = score;
  document.getElementById('lines').innerText = lines;
  document.getElementById('level').innerText = level;

  // Atualiza visual dos recordes
  let hsText = highscores.map((v,i)=> `${i+1}º - ${v}`).join("<br>");
  document.getElementById("highscores").innerHTML = hsText || "—";
}

function randomPiece(){
  const keys = Object.keys(SHAPES);
  const type = keys[Math.floor(Math.random()*keys.length)];
  const shape = SHAPES[type].map(r => r.slice());
  return {matrix: shape, color: COLORS[type], type};
}

function playerReset(){
  piece = next || randomPiece();
  next = randomPiece();
  piece.x = Math.floor((COLS - piece.matrix[0].length)/2);
  piece.y = 0;
  if(collapsePieces()){
    // game over
    gameOver = true;
    paused = true;
    // Salvar recordes
    highscores.push(score);
    highscores = highscores.sort((a,b)=>b-a).slice(0,3);
    localStorage.setItem("tetrisHighscores", JSON.stringify(highscores));
    updateInfo();

    document.getElementById("finalScore").innerText = score;
    document.getElementById("gameOverBox").style.display = "flex";
    // mostrar botão iniciar novamente após game over
    const sb = document.getElementById('startBtn'); if(sb) sb.style.display = 'inline-flex';
  }
  drawNext();
}

function collapsePieces(){
  if(colliderTop()) return true;
  return false;
}

function colliderTop(){
  if(collide(arena, piece)) return true;
  return false;
}

function playerDrop(){
  piece.y++;
  if(collide(arena,piece)){
    piece.y--;
    merge(arena,piece);
    sweep();
    playerReset();
  }
  dropCounter = 0;
}

function hardDrop(){
  while(!collide(arena,piece)) piece.y++;
  piece.y--;
  merge(arena,piece);
  sweep();
  playerReset();
}

function playerMove(dir){
  piece.x += dir;
  if(collide(arena,piece)) piece.x -= dir;
}

function playerRotate(dir){
  const pos = piece.x;
  rotate(piece.matrix, dir);
  // tenta compensar colisões
  let offset = 1;
  while(collide(arena,piece)){
    piece.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(offset > piece.matrix[0].length){
      rotate(piece.matrix, -dir);
      piece.x = pos;
      return;
    }
  }
}

function update(time=0){
  if(paused){ lastTime = time; requestAnimationFrame(update); return; }
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}

// teclado
document.addEventListener('keydown', e => {
  if(gameOver) return;
  if(e.key === 'a') playerMove(-1);
  else if(e.key === 'd') playerMove(1);
  else if(e.key === 's') playerDrop();
  else if(e.key === 'w' || e.key.toLowerCase() === 'x') playerRotate(1);
  else if(e.code === 'Space') { e.preventDefault(); hardDrop(); }
  else if(e.key.toLowerCase() === 'e') paused = !paused;
  else if(e.key.toLowerCase() === 'r') restart();
  draw();
});

function restart(){

  document.getElementById("gameOverBox").style.display = "none";
  arena = createMatrix(COLS, ROWS);
  score = 0; lines = 0; level = 1; dropInterval = 1000; gameOver = false; paused = false;
  next = randomPiece();
  playerReset();
  updateInfo();
  // esconder botão iniciar ao reiniciar
  const sb = document.getElementById('startBtn'); if(sb) sb.style.display = 'none';

}

// função chamada pelo botão Iniciar
function startGame(){
  const sb = document.getElementById('startBtn'); if(sb) sb.style.display = 'none';
  paused = false;
  startMusic();
}

// inicia
const restartBtn = document.getElementById('restart');
if (restartBtn) {
  restartBtn.addEventListener('click', restart);
}

next = randomPiece();
playerReset();
updateInfo();
update();
</script>

<script>
// --- ÁUDIO --- //
const bgMusic = new Audio("sounds/bg-music.mp3");
bgMusic.loop = true;
bgMusic.volume = 0.4;

const gameOverSound = new Audio("sounds/gameover.mp3");

const lineSounds = {
  1: new Audio("sounds/line1.mp3"),
  2: new Audio("sounds/line2.mp3"),
  3: new Audio("sounds/line3.mp3"),
  4: new Audio("sounds/line4.mp3"),
  5: new Audio("sounds/line5.mp3")
};
Object.values(lineSounds).forEach(s => s.volume = 0.7);

function startMusic() {
  if (bgMusic.paused) {
    bgMusic.play().catch(()=>{}); // Alguns navegadores bloqueiam até interação
  }
}

function stopMusic() {
  bgMusic.pause();
  bgMusic.currentTime = 0;
}

// --- ANIMAÇÕES --- //
let effects = [];

function animateLines(rowCount) {
  const colors = {
    1: "rgba(0,255,0,0.6)",
    2: "rgba(0,200,255,0.6)",
    3: "rgba(255,200,0,0.6)",
    4: "rgba(255,0,200,0.7)",
    5: "rgba(255,50,50,0.8)"
  };

  // 🔊 som da linha
  if (lineSounds[rowCount]) {
    lineSounds[rowCount].currentTime = 0;
    lineSounds[rowCount].play();
  }

  // flash
  effects.push({
    type: "flash",
    color: colors[rowCount] || "rgba(255,255,255,0.6)",
    time: 0,
    duration: 500
  });

  // partículas para 3+
  if (rowCount >= 3) {
    for (let i = 0; i < 30; i++) {
      effects.push({
        type: "particle",
        x: canvas.width / 2,
        y: canvas.height / 2,
        dx: (Math.random() - 0.5) * 6,
        dy: (Math.random() - 0.5) * 6,
        color: colors[rowCount],
        life: 1000,
        time: 0
      });
    }
  }
}

function drawEffects(delta) {
  for (let i = effects.length - 1; i >= 0; i--) {
    const e = effects[i];
    e.time += delta;

    if (e.type === "flash") {
      let alpha = 1 - e.time / e.duration;
      if (alpha > 0) {
        ctx.fillStyle = e.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
      } else {
        effects.splice(i, 1);
      }
    }

    if (e.type === "particle") {
      if (e.time < e.life) {
        let progress = 1 - e.time / e.life;
        ctx.fillStyle = e.color;
        ctx.globalAlpha = progress;
        ctx.beginPath();
        ctx.arc(e.x, e.y, 4 * progress, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        e.x += e.dx;
        e.y += e.dy;
      } else {
        effects.splice(i, 1);
      }
    }
  }
}

// --- MODIFICAÇÕES NO JOGO --- //
function sweep() {
  let rowCount = 0;
  outer: for (let y = ROWS - 1; y >= 0; y--) {
    for (let x = 0; x < COLS; x++) {
      if (!arena[y][x]) {
        continue outer;
      }
    }
    const row = arena.splice(y, 1)[0].fill(0);
    arena.unshift(row);
    y++;
    rowCount++;
  }

  if (rowCount > 0) {
    animateLines(rowCount);

    const points = [0, 40, 100, 300, 1200];
    score += points[rowCount] * level;
    lines += rowCount;
    const newLevel = Math.floor(lines / 10) + 1;
    if (newLevel > level) {
      level = newLevel;
      dropInterval = Math.max(100, 1000 - (level - 1) * 100);
    }
    updateInfo();
  }
}

function playerReset() {
  piece = next || randomPiece();
  next = randomPiece();
  piece.x = Math.floor((COLS - piece.matrix[0].length) / 2);
  piece.y = 0;
  if (colliderTop()) {
    gameOver = true;
    paused = true;
    stopMusic();
    gameOverSound.play();
    // Salvar recordes
    highscores.push(score);
    highscores = highscores.sort((a,b)=>b-a).slice(0,3);
    localStorage.setItem("tetrisHighscores", JSON.stringify(highscores));
    updateInfo();

    document.getElementById("finalScore").innerText = score;
    document.getElementById("gameOverBox").style.display = "flex";
    // mostrar botão iniciar novamente
    const sb = document.getElementById('startBtn'); if(sb) sb.style.display = 'inline-flex';
  }
  drawNext();
}

function update(time = 0) {
  if (paused) { lastTime = time; requestAnimationFrame(update); return; }
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval) {
    playerDrop();
  }
  draw();
  drawEffects(delta);
  requestAnimationFrame(update);
}

function restart(){
  document.getElementById("gameOverBox").style.display = "none";

  arena = createMatrix(COLS, ROWS);
  score = 0; lines = 0; level = 1; dropInterval = 1000; gameOver = false; paused = false;
  next = randomPiece();
  playerReset();
  updateInfo();
  startMusic(); // música reinicia
  // esconder botão iniciar ao reiniciar
  const sb = document.getElementById('startBtn'); if(sb) sb.style.display = 'none';
}

// --- INICIALIZAÇÃO --- //
next = randomPiece();
playerReset();
updateInfo();
update();

// 🔊 só começa música depois de interação
document.addEventListener("keydown", () => {
  startMusic();
}, { once: true });

// conecta o botão Iniciar
const startButton = document.getElementById('startBtn');
if(startButton) startButton.addEventListener('click', startGame);
</script>
 

<script>
// === SUPORTE A CONTROLE DE VIDEOGAME (Gamepad API) ===
let gamepadIndex = null;

window.addEventListener("gamepadconnected", (e) => {
  gamepadIndex = e.gamepad.index;
  console.log("Controle conectado:", e.gamepad.id);
});

window.addEventListener("gamepaddisconnected", () => {
  console.log("Controle desconectado");
  gamepadIndex = null;
});

// Guardar estado para não repetir ação contínua
let pressed = {};

// Cooldowns em ms para cada ação
const repeatDelay = {
  move: 150,   // 150ms entre movimentos laterais
  down: 80     // 80ms entre quedas suaves
};

// Guarda o tempo da última ação
let lastAction = {
  left: 0,
  right: 0,
  down: 0
};

function handleGamepad() {
  if (gamepadIndex === null) return;
  const gp = navigator.getGamepads()[gamepadIndex];
  if (!gp) return;

  let eixoX = gp.axes[0]; 
  let eixoY = gp.axes[1]; 
  let now = performance.now();

  // Movimento contínuo esquerda
  if (eixoX < -0.4 || gp.buttons[4].pressed) {
    if (now - lastAction.left > repeatDelay.move) {
      playerMove(-1);
      lastAction.left = now;
    }
  }

  // Movimento contínuo direita
  if (eixoX > 0.4 || gp.buttons[5].pressed) {
    if (now - lastAction.right > repeatDelay.move) {
      playerMove(1);
      lastAction.right = now;
    }
  }

  // Queda suave contínua
  if (eixoY > 0.5 || gp.buttons[1].pressed) {
    if (now - lastAction.down > repeatDelay.down) {
      playerDrop();
      lastAction.down = now;
    }
  }

  // --- Botões de ação única ---
  if (gp.buttons[0].pressed) { // A = hard drop
    if (!pressed["A"]) hardDrop();
    pressed["A"] = true;
  } else pressed["A"] = false;

  if (gp.buttons[2].pressed) { // X = rotacionar
    if (!pressed["X"]) playerRotate(1);
    pressed["X"] = true;
  } else pressed["X"] = false;

  if (gp.buttons[3].pressed) { // Y = reiniciar
    if (!pressed["Y"]) restart();
    pressed["Y"] = true;
  } else pressed["Y"] = false;

  if (gp.buttons[8].pressed) { // Back = iniciar/reiniciar
    if (!pressed["BACK"]) {
      if (paused && !gameOver) startGame();
      else if (gameOver) restart();
    }
    pressed["BACK"] = true;
  } else pressed["BACK"] = false;

  if (gp.buttons[9].pressed) { // Start = pausar
    if (!pressed["START"]) paused = !paused;
    pressed["START"] = true;
  } else pressed["START"] = false;
}


// Loop de leitura do controle
function gamepadLoop() {
  handleGamepad();
  requestAnimationFrame(gamepadLoop);
}
gamepadLoop();
</script>

</body>
</html>

